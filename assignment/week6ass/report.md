# CS302 OS Week6 Assignment - Report

Name: 刘仁杰
SID: 11911808

## 1. Read Chapter 15 of "Three Easy Pieces"

* The hardware provides base and bound register as part of MMU of the CPU.
* When a user program is running, the hardware will translate each address, by adding the base register value to the virtual address generated by the user program. 
* Also, the hardware will check if the address is legal, by using the bound register. If not, the hardware will throw an exception which will be caught by the OS and dispatch corresponding exception handler.
* In OS kernel mode, there are some hardware APIs for the kernel to change the value of base and bound register, which will enable OS to handle multiprocessing.
* In user mode, if the user program tries to change the value of base and bound register, the CPU hardware will also raise an exception and the OS will trigger corresponding handler.

## 2. Read Chapter 16 and 18 of "Three Easy Pieces"

1. Segmentation

* size of chunk: Variable-sized.
* management of free space: Use a free-list management algorithm that tries to keep large extents of memory available for allocation, such as best-fit, worst-fit and first-fit.
* context switch overhead: The segment registers must be saved and restored.
* fragmentation: Free of internal fragmentation while suffers from external fragmentation.
* status bits: There is no status bit in segmentation.
* protection bits: To support sharing, the basic implementation adds a few bits per segment, indicating whether or not a program can read or write a segment, or perhaps execute code that lies within the segment. Then the hardware will not only check if the want-to-access address is within bound, also should be permissible.

1. Paging

* size of chunk: Divide the process space into fixed-sized units.
* management of free space: More simple, OS keeps a free list of all free pages for this, and just grabs the first several pages that satisfy the demanded size off of this list.
* context switch overhead: On context switch, just simply changes the pointer to the page table.
* fragmentation: No external fragmentation, have internal fragmentation.
* status bits: There are 9 status bits, indicate D (dirty), A (accessed), V (valid), G (Global), U (User) and RSW
* protection bits: There are also protection bits, indicating whether the page could be read from, written to, or executed from. Again, accessing a page in a way not allowed by these bits will generate a trap to the OS.

## 3. How many levels of page tables would be required to map the entire virtual address space

There should be at least 3 levels of page tables.

Since Page size is of 8 KBytes, namely $2^{13}$ Bytes, which will take 13 bits of virtual address space. Now, 33 bits are left.

Then if every page table is required to fit into a single page with each size of 4 Bytes, there should at most be $2^{11}$ entry in a page table, which will take at most 11 bits of virtual address space.

So, there should be at least 3 levels of page tables with each occupy at most 11 bits of virtual address space.

Finally, the format of a virtual address should be:

* bit 0~12 for offset
* bit 13~23 for L3 index
* bit 24~34 for L2 index
* bit 35~45 for L1 index

## 4. Problem 4

(a) What is the page size? What is the maximum page table size?

page size: $2^{12} \ Bytes = 4 \ KBytes$.

maximum page table size: $2^{20} \times 4 \ Bytes= 4 \ MBytes$

(b) Suppose it uses 2-level page table

* virtual address 0xC302C302

1-st level page number: 1100 0011 00(2) = 780(10)

offset: 0011 0000 0010(2) = 770(10)

* virtual address 0xEC6666AB

2-nd level page number: 10 0110 0110(2) = 614(10)

offset: 0110 1010 1011(2) = 1707(10)

## 5. Please realize merging free blocks in default_free_pages()

Codes:

![Screenshot from 2022-03-28 20-36-10](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-36-10.png)

Result Display:

![Screenshot from 2022-03-28 20-49-29](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-30-58.png)

## 6. Realize bestfit in best_fit_pmm.c

Codes:

* init

![Screenshot from 2022-03-28 20-50-21](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-50-21.png)

* init_memmap

![Screenshot from 2022-03-28 20-50-33](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-50-33.png)

* alloc

![Screenshot from 2022-03-28 20-50-45](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-50-45.png)

* free

![Screenshot from 2022-03-28 20-51-02](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-51-02.png)

![Screenshot from 2022-03-28 20-51-15](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-51-15.png)

Result Display:

![Screenshot from 2022-03-28 20-49-29](/home/lrj11911808/Pictures/Screenshot from 2022-03-28 20-49-29.png)
